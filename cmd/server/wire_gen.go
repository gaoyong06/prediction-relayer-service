// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package main

import (
	"fmt"
	"github.com/ethereum/go-ethereum/ethclient"
	"github.com/go-kratos/kratos/v2"
	"github.com/go-kratos/kratos/v2/log"
	"gorm.io/gorm"
	"math/big"
	"strconv"
	"time"
	"xinyuan_tech/relayer-service/internal/auth"
	"xinyuan_tech/relayer-service/internal/biz"
	"xinyuan_tech/relayer-service/internal/conf"
	"xinyuan_tech/relayer-service/internal/data"
	"xinyuan_tech/relayer-service/internal/executor"
	"xinyuan_tech/relayer-service/internal/fee"
	"xinyuan_tech/relayer-service/internal/kms"
	"xinyuan_tech/relayer-service/internal/monitor"
	"xinyuan_tech/relayer-service/internal/nonce"
	"xinyuan_tech/relayer-service/internal/server"
	"xinyuan_tech/relayer-service/internal/service"
)

import (
	_ "go.uber.org/automaxprocs"
)

// Injectors from wire.go:

func wireApp(c *conf.Bootstrap, logger log.Logger) (*kratos.App, func(), error) {
	confServer := c.Server
	confData := c.Data
	db, cleanup, err := data.NewDB(confData, logger)
	if err != nil {
		return nil, nil, err
	}
	client, cleanup2, err := data.NewRedis(confData, logger)
	if err != nil {
		cleanup()
		return nil, nil, err
	}
	rocketMQProducer, cleanup3, err := data.NewRocketMQ(confData, logger)
	if err != nil {
		cleanup2()
		cleanup()
		return nil, nil, err
	}
	dataData, cleanup4, err := data.NewData(confData, logger, db, client, rocketMQProducer)
	if err != nil {
		cleanup3()
		cleanup2()
		cleanup()
		return nil, nil, err
	}
	builderRepo := data.NewBuilderRepo(dataData)
	builder := c.Builder
	authService := NewAuthService(builderRepo, builder)
	transactionRepo := data.NewTransactionRepo(dataData)
	chain := c.Chain
	ethclientClient, cleanup5, err := NewEthClient(chain)
	if err != nil {
		cleanup4()
		cleanup3()
		cleanup2()
		cleanup()
		return nil, nil, err
	}
	bigInt, err := NewChainID(chain)
	if err != nil {
		cleanup5()
		cleanup4()
		cleanup3()
		cleanup2()
		cleanup()
		return nil, nil, err
	}
	operatorRepo := data.NewOperatorRepo(dataData)
	manager := NewNonceManager(db, operatorRepo, ethclientClient)
	executor := NewExecutor(ethclientClient, bigInt, manager, operatorRepo, chain)
	builderFeeRepo := data.NewBuilderFeeRepo(dataData)
	tracker := NewFeeTracker(builderFeeRepo)
	relayerService := biz.NewRelayerService(authService, transactionRepo, executor, tracker)
	serviceRelayerService := service.NewRelayerService(relayerService, authService, logger)
	httpServer := server.NewHTTPServer(confServer, serviceRelayerService, logger)
	grpcServer := server.NewGRPCServer(confServer, serviceRelayerService, logger)
	monitor := NewMonitor(ethclientClient, transactionRepo, executor, logger)
	monitorRunner := server.NewMonitorRunner(monitor, logger)
	app := newApp(logger, httpServer, grpcServer, monitorRunner)
	return app, func() {
		cleanup5()
		cleanup4()
		cleanup3()
		cleanup2()
		cleanup()
	}, nil
}

// wire.go:

// NewEthClient 创建以太坊客户端
func NewEthClient(c *conf.Chain) (*ethclient.Client, func(), error) {
	client, err := ethclient.Dial(c.RpcUrl)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to connect to ethereum client: %w", err)
	}
	cleanup := func() {
		if client != nil {
			client.Close()
		}
	}
	return client, cleanup, nil
}

// NewChainID 创建 Chain ID
func NewChainID(c *conf.Chain) (*big.Int, error) {
	chainID, err := strconv.ParseInt(c.ChainId, 10, 64)
	if err != nil {
		return nil, fmt.Errorf("failed to parse chain ID: %w", err)
	}
	return big.NewInt(chainID), nil
}

// NewAuthService 创建认证服务
func NewAuthService(
	builderRepo data.BuilderRepo,
	c *conf.Builder,
) auth.AuthService {
	timestampWindow := int64(5 * 60 * 1000)
	if c != nil && c.TimestampWindowMs > 0 {
		timestampWindow = c.TimestampWindowMs
	}
	return auth.NewAuthService(builderRepo, timestampWindow)
}

// NewNonceManager 创建 Nonce 管理器
func NewNonceManager(
	db *gorm.DB,
	operatorRepo data.OperatorRepo,
	ethClient *ethclient.Client,
) nonce.Manager {
	return nonce.NewManager(db, operatorRepo, ethClient)
}

// NewExecutor 创建交易执行器
func NewExecutor(
	ethClient *ethclient.Client,
	chainID *big.Int,
	nonceMgr nonce.Manager,
	operatorRepo data.OperatorRepo,
	c *conf.Chain,
) executor.Executor {
	gasMultiplier := int64(110)
	if c != nil && c.GasPriceMultiplier > 0 {
		gasMultiplier = c.GasPriceMultiplier
	}
	return executor.NewExecutor(ethClient, chainID, nonceMgr, operatorRepo, gasMultiplier)
}

// NewFeeTracker 创建费用追踪器
func NewFeeTracker(feeRepo data.BuilderFeeRepo) fee.Tracker {
	return fee.NewTracker(feeRepo)
}

// NewMonitor 创建交易监控器
func NewMonitor(
	ethClient *ethclient.Client,
	txRepo data.TransactionRepo,
	exec executor.Executor,
	logger log.Logger,
) monitor.Monitor {
	pendingTimeout := 30 * time.Second
	return monitor.NewMonitor(ethClient, txRepo, exec, logger, pendingTimeout)
}

// NewKMS 创建 KMS 服务
func NewKMS(c *conf.Security) (kms.KMS, error) {
	kmsType := "local"
	if c != nil && c.KmsType != "" {
		kmsType = c.KmsType
	}
	kmsConfig := ""
	if c != nil {
		kmsConfig = c.KmsConfig
	}
	return kms.NewKMS(kmsType, kmsConfig)
}
